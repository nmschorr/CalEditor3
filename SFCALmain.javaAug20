package sfcalmain;
/* SFCALmain.java by Nancy Schorr, 2015, 2022
 *
 * This program removes extra calendar events from an ics calendar file.
 * 
 * The data for the calendar is calculated with Solar Fire 8 on Windows XP.  
 * It is run through the Perl script, then the Word macros.  
 * Ideally that would all take place in one Java executable -
 * but that's a project for the future.

 * This little program is the final step in preparing the SFCAL.ics file 
 * for uploading in Google or another calendar system.
**/

// Note: can't use an iterator because the file isn't being read that way

import java.io.File;
import java.io.IOException;
import java.util.*;
import static java.lang.System.out;
import org.apache.commons.io.FileUtils;
import static java.util.Map.entry;    

//must be run with java -Dfile.encoding=UTF-8 SCALperson
//otherwise doesn't work

/**
 * This class contains methods that remove extra calendar events from an ics calendar file.
 * @author Nancy M. Schorr
 * @version 1.2
 * 
 */

public class SFCALmain {
	public static final String indirMAIN = "H:\\sfcalfiles\\standard";
	public static final String outDIR = "C:\\SFCALOUT\\standard";
	
	static int G_VERBOSE = 0;
	static final String newfront  =  "DTEND:";
    public static final char LF = '\n';
    public static final char CR = '\r';
    public static final String EMPTYstr = "";
    protected static final Map<String, String> signsMap = Map.ofEntries(
	    entry("Cn", "Cancer "), entry("Ar", "Aries "), entry("Ta", "Taurus "), entry("Sg", "Sagittarius "),
		entry("Ge", "Gemini "), entry("Le", "Leo "), entry("Vi", "Virgo "), entry("Li", "Libra "),
		entry("Sc", "Scorpio "), entry("Cp", "Capricorn "), entry("Aq", "Aquarius "), entry("Pi", "Pisces " ));	
	protected static final HashMap <String, String> signHashMap =  new HashMap<>(signsMap);
	protected static final Map<String, String> planSigns = Map.ofEntries(
		 entry("Mon", "Moon"), entry("Ari", "Aries"), entry("Tau", "Taurus"), entry("Gem", "Gemini"), 
		 entry("Can", "Cancer"),  entry("Leo", "Leo"), entry("Vir", "Virgo"), entry("Lib", "Libra"), entry("Sco", "Scorpio"), 
		 entry("Sag", "Sagittarius"),   entry("Cap", "Capricorn"), entry("Aqu", "Aquarius"),  entry("Pis", "Pisces"),
		 entry("Cnj", "Conjunct"), entry("Tri", "Trine"), entry("Opp", "Opposite"), entry("Sqr", "Square"),
		 entry("Sxt", "Sextile"), entry("Qnx", "Quincunx"), entry("Sun", "Sun"), entry("Mer", "Mercury"), 
		 entry("Ven", "Venus"),  entry("Mar", "Mars"), entry("Jup", "Jupiter"), entry("Sat", "Saturn"), 
		 entry("Nep", "Neptune"), entry("Ura", "Uranus"), entry("Plu", "Pluto")	);
	protected static final HashMap <String, String> planSignsAsp = new HashMap<>(planSigns);
	
	public static void main(String[] args) {	
		String outDIRTMP = outDIR + "\\tempfiles";
		String[] arryOfInFiles = getflist(indirMAIN);	// create a list of names of those files	
		int fileInDirCNT=0;
		int arraysize = arryOfInFiles.length;

		while (fileInDirCNT < arraysize) {  
			String infileNM= arryOfInFiles[fileInDirCNT];
			String inFILEstr = indirMAIN +"\\" + infileNM;
			   
			out.println("-- starting over in main LOOP# " + fileInDirCNT+1 +" filename is: " + infileNM);
			
			String finFILEnmWdir = mkDateFileNM(inFILEstr, infileNM, outDIR);
			delFiles(finFILEnmWdir);  // delete the inFileName we made last time
			 
			String tOUTone = getTMPnmWdir(outDIRTMP,"-one");
			String tOUTtwo = getTMPnmWdir(outDIRTMP,"-two");
				
			generalStringFixing( inFILEstr, tOUTone);
			
			sectionTaskTwo(tOUTone, tOUTtwo, finFILEnmWdir);
			
			out.println("- datefilename is: " + finFILEnmWdir+"--------End of Loop------------NEW filename is: "+finFILEnmWdir);		
			
			fileInDirCNT++;		
		}			
		out.println("Finished Program");
	}

	static String getTMPnmWdir(String tnm, String myIn) {  // 1 for name, 2 for file
		return tnm + "\\SFCALtmp" + System.currentTimeMillis() +myIn +".ics";
		}

	static String[] getflist(String dnm) {  // 1 for name, 2 for file
		return new File(dnm).list();	// create a list of names of those files	
		}

	public static void verboseOut(String theoutline) {
		if (G_VERBOSE==1) {
			out.println(theoutline);
		}
	}
	
// new method // --------------------------------------------------------------	 	
	static String fixDESCRIPTION_line( String  inSTRING) {
		CharSequence badLINEFchars = "\\n";
		String badLINEFstr = (String)badLINEFchars;
		String newstr = EMPTYstr;
		out.println("just entered gofixDES. oldstrg is: " +inSTRING );

		String tString = inSTRING.replaceAll("%0A",EMPTYstr);  // get rid of CRs  - \n
		if (tString.contains(badLINEFchars))    // for newline only
			newstr = tString.replace(badLINEFstr, " - ");
		else newstr = tString;
		
		tString = continueReplacing(newstr);
	 		
		if (tString.startsWith(" "))   // spelling errors in extra lines of DESCRIPTION
			tString = newrepl(tString);
	
		return tString;
	}

	static String newrepl(String localSTR) {
		String oldVal;
		String newVal;
		String newstr = localSTR;
		HashMap<String, String> hMAP = makeSpellhm();
		for (String key : hMAP.keySet()) {
			oldVal= key;
			newVal= hMAP.get(key);
			out.println("-- value of hmap retrieval: " + oldVal + " " + newVal);
			if (localSTR.contains(oldVal)) {
			    newstr = localSTR.replace(oldVal, newVal);
				out.println("SPELLING ERROR!!!! ----------replaced string with new string... now fixed: " + newstr);
			}
		} //for
	return newstr;
	}
		
		
	static String continueReplacing(String fixmeSTR) {
		String origStr = fixmeSTR;

		String newTempStr = fixmeSTR.replace("Transiting ",EMPTYstr );
		fixmeSTR = newTempStr.replace("Conjunction","Conjunct"); 
		newTempStr = fixmeSTR.replace("Opposition","Opposite"); 
		fixmeSTR = newTempStr.replace("Entering","Enters" );
		
		newTempStr = fixmeSTR.replace("DESCRIPTION:The ","DESCRIPTION:" );
		
		if (newTempStr.contains("Aint")) {
			fixmeSTR = newTempStr.replace("Aint","Ain\'t" );
			newTempStr = fixmeSTR;
		}
		
		if ((newTempStr.contains("DESCRIPTION:Mars Enter")) || (newTempStr.contains("DESCRIPTION:Transiting Mars Enter")) )
		{
			String badString = "DESCRIPTION:Mars Enters Gemini - Time to nitiate";			
			String goodString = "DESCRIPTION:Mars Enters Gemini - Time to initiate";
			newTempStr = newTempStr.replace(badString, goodString );
		}
		
		out.println("new string fixed: old: " + origStr + " new: " + newTempStr);
		return newTempStr;
	}

	
// new method // --------------------------------------------------------------	 	
	static String fixSUMMARYsigns(String oldstrg, boolean isDIRorRET) {
		String tstring = oldstrg.replace("SUMMARY: ", "SUMMARY:");
		 
		String newstr = "empty";
		StringBuffer newbuf = new StringBuffer(tstring);

		List<String> signsARRAY = (Arrays.asList("Ari", "Tau","Gem", "Can", "Leo", 
			"Vir", "Lib","Sco", "Sag", "Cap", "Aqu", "Pis"));
		boolean signmatch =false;
	 		 		
		String firstthird = EMPTYstr;
		String secondthird = EMPTYstr;
		String lastthird = EMPTYstr;
		
		if (!isDIRorRET) {
			lastthird = tstring.substring(22,25);
			firstthird = tstring.substring(14,17);
			if (signsARRAY.contains(lastthird))				
				signmatch = true;
		}
		out.println("in fixSUMMARYsigns. first:  " + firstthird+" 2nd  :  " + secondthird+" 3rd  :  " + lastthird);
//begin third column		    
		if (!isDIRorRET) {
			String thirdrep = planSignsAsp.get(lastthird);			
			int start = 22;
			int end = 25;
			newbuf.delete(start, end); 
			newbuf.insert(start,thirdrep);
			out.println("found this in hash:  " + lastthird+"new buf is: " + newbuf);		
		}		
//begin second column
		if  (!isDIRorRET) {
			secondthird = tstring.substring(18,21);
			String secondrep = planSignsAsp.get(secondthird);
			int start = 18;
			int end = 21;
			newbuf.delete(start, end); 
			if (signmatch) {   // change Conjunct a sign to Enters a sign
				newbuf.insert(start,"Enters");
			} else {
				newbuf.insert(start,secondrep);
			}
			out.println("value of signmatch:  " + signmatch+ "found this in hash:  " + secondrep+"new buf is: " + newbuf);
		}			
// begin first column		
		if (isDIRorRET) {
			firstthird = tstring.substring(8,11);
			String longsign = planSignsAsp.get(firstthird);
			newstr = tstring.replace(firstthird, longsign);
		}
		if (!isDIRorRET) {
			String firstrep = planSignsAsp.get(firstthird);

			int start = 8;
			int end = 17;
			newbuf.delete(start, end); 
			newbuf.insert(8,firstrep);
			newstr =   newbuf.toString();
			out.println("found this in hash:  " + firstrep + "new buf is: " + newbuf);
			out.println("replaced string with new string... now fixed: " + newstr);
			out.println("value of newstr:  " + newstr+ "return this new value  " + newstr);
		}
		
		return newstr;
	} // gofixhash
	
	
// new method // --------------------------------------------------------------	 	
	static HashMap<String, String> makeSpellhm() {
		HashMap <String, String> spellhm  =  new HashMap<>();
		spellhm.put("Stabilise","Stabilize");
		spellhm.put("Socialise","Socialize");
		spellhm.put("Entering","Enters");
		spellhm.put("organised","organized");
		spellhm.put("excelent","excellent");
		spellhm.put("realise","realize");
		spellhm.put("Organise","Organize");
		spellhm.put("Strategise","Strategize");
		spellhm.put("Strategise","Strategize");
		spellhm.put("spiritualilty","spirituality");
		spellhm.put("wilfull","willful");
		spellhm.put("possibiities","possibilities");
		spellhm.put("fantasise","fantasize");
		spellhm.put("behaviour","behavior");
		spellhm.put("Aint","Ain't");
		return spellhm;
	}
	
// new method // --------------------------------------------------------------	 	
	static String mkDateFileNM(String oldFileWDir, String oldname, String newfiledir) {
		List<String> oldfileAR = new ArrayList<>();
		String newDateNM = EMPTYstr;
		String theTst = "DTSTART";
		int whileCT = 0;
		String tmpSTR = EMPTYstr;
		String newDateStr = EMPTYstr;
		int indColon = 0;
		int tStart=0;
		int tEnd=0;
		
		try {
			oldfileAR =  FileUtils.readLines(new File(oldFileWDir));  //READ the list of files in sfcalfiles/vds dir
			while ( whileCT < 15) {
				tmpSTR = oldfileAR.get(whileCT);
				if ( tmpSTR.contains(theTst)) {
					indColon = tmpSTR.indexOf(":");
					tStart=indColon+1;
					tEnd=tStart+8;
			        newDateStr = tmpSTR.substring(tStart, tEnd);
			        newDateNM = newfiledir + "\\" + oldname + "." + newDateStr + ".ics";
			        break;
			  }
			  whileCT++;
			}
		} catch (IOException e) { 
			e.printStackTrace();	
		}	// catch
		return newDateNM; 
	}
	
   public static String chomp(String str) {
        if (str.length() == 0) {
            return str;
        }
        if (str.length() == 1) {
            char ch = str.charAt(0);
            if (ch == CR || ch == LF) {
                return EMPTYstr;
            }
            return str;
        }
        int lastIdx = str.length() - 1;
        char last = str.charAt(lastIdx);

        if (last == LF) {
            if (str.charAt(lastIdx - 1) == CR) {
                lastIdx--;
            }
        } else if (last != CR) {
            lastIdx++;
        }
        return str.substring(0, lastIdx);
    }

	// new method // --------------------------------------------------------------	 		
	static void generalStringFixing(String origFILEnm, String tmpFILEnmONE ) {   
		List<String> nwARRY  =  new ArrayList<>();
		File origFILE = new File(origFILEnm);
		File SFCALtempONE  =  new File(tmpFILEnmONE);
		CharSequence SUMstr = "SUMMARY:Tr-Tr";
		String cLINEtwo = EMPTYstr;
		String DEStr = "DESCRIPTION";
		String theDTENDline=EMPTYstr;
		G_VERBOSE = 0;
		
		try {
			List<String> origFILEARRY  =   FileUtils.readLines(origFILE);
			int arraySIZE  =  origFILEARRY.size();
			System.out.println("orig file size:  " +  arraySIZE   );			
			System.out.println("----------------------------------%%%%%%%##### total lines: " +  origFILEARRY.size());
			// get ics header lines in 1st-first four header lines of ics inFileName
			int lineCOUNT =0;
			String cLINE;

			// for each line in file:
			while (lineCOUNT < arraySIZE) {
				System.out.println("myLINEct:  " + lineCOUNT);
				cLINE = origFILEARRY.get(lineCOUNT);
				cLINEtwo = chomp(cLINE);  // chomp is removing the Z
				cLINE = chkForWeirdChar(cLINEtwo);
				System.out.println("    char string is:         " + cLINE);
					// the if's start here
					// begin the IFS			
				if ( cLINE.contains(SUMstr)) {  /// if TR-TR only lines
					cLINEtwo = fixSUMMARYsigns(cLINE, false) ;
					nwARRY.add(cLINEtwo);
				}			
				else if ( cLINE.contains("Full Moon") || cLINE.contains("New Moon")) {
					cLINEtwo = replaceSigns(cLINE);
					cLINE = cLINEtwo;
					nwARRY.add(cLINE );
				} 
				
				else if ( cLINE.contains(DEStr) || cLINE.startsWith(" "))   {  /// if TR-TR only lines
						cLINEtwo = fixDESCRIPTION_line(cLINE) ;
						nwARRY.add(cLINEtwo);
					}										
					else if (cLINE.startsWith("SUMMARY:Tr "))   { // direct or retrograde
						cLINEtwo= fixDirRetro(cLINE);
						cLINEtwo = fixSUMMARYsigns(cLINEtwo, true) ;
						nwARRY.add(cLINEtwo );
					}  // SUMMARY:TR 	

					
					else if ( (cLINE.contains(";VALUE")) && ( cLINE.contains("DT")) )  { // moon for the day
						nwARRY.add(cLINE );
					}  // SUMMARY:TR 
				
					else if ( cLINE.contains("DTSTAR") ) {
						if (!cLINE.contains("VALUE")) { //skip these; they are moon for the day
							theDTENDline = chkAddDTEND(cLINE);
							nwARRY.add(cLINE );
							nwARRY.add(theDTENDline );
						}
					}
					else if (cLINE.contains("Moon goes void")) {
						cLINEtwo = "SUMMARY:Moon void of course";
						int newSIZE  =  nwARRY.size();

						int back_three_count = newSIZE - 5;
						int back_two_count = newSIZE - 4;
						System.out.println("------here's back three----");
						String back_3_str = nwARRY.get(back_three_count);
						System.out.println("old string: " + back_3_str);
						String newDTSTART = fixDTSTART(back_3_str);
						String new_DTEND_line = stdUtilCreateDTEND(back_3_str);
						
						nwARRY.set(back_three_count, newDTSTART);
						nwARRY.set(back_two_count, new_DTEND_line);
						
						nwARRY.add(cLINEtwo );
						lineCOUNT++;
						}
					
					else {
						System.out.println("   writing ORIGINAL string to file         " + cLINE);
						nwARRY.add(cLINE );
					}
				lineCOUNT++;
				cLINEtwo =EMPTYstr;
			}  // while lines in file arrray
			System.out.println("Writing to file: " + SFCALtempONE.getName());
			FileUtils.writeLines(SFCALtempONE, nwARRY);	
			System.out.println("first end");
		}  // try
				catch (IOException e)  { 
					e.printStackTrace();	 
					}  // catch
	}	// end of method

	static String fixDTSTART(String uline) {
		String partialEND = uline.substring(8,22) + "1Z";
		String newstr ="DTSTART:" + partialEND;					
		verboseOut("DTSTART: new line is " + newstr);
		return newstr;
	}

	static String stdUtilCreateDTEND(String utline) {
		String partialEND = utline.substring(8,22) + "1Z";
		String newDTENDstr ="DTEND:" + partialEND;					
		verboseOut("DTEND: new line is " + newDTENDstr);
		return newDTENDstr;	
	}
	
	static String fixDirRetro(String retroString) {
		String charD = " D";  
		String charR = " R";  // MUST have a space first
		
		if (retroString.startsWith("SUMMARY:Tr "))   { 
			String retStringTwo = retroString.replace("Tr ", EMPTYstr);
			int cStart = retStringTwo.length()-3;  // a space & there's a line ending too
			int cEnd = retStringTwo.length()-1;
			String tempSub = retStringTwo.substring(cStart,cEnd);  // get the last char
			if (tempSub.equals(charR))  {  
				retroString  = retStringTwo.replace(charR, " goes Retrograde");
			}
			else if (tempSub.equals(charD))  { 			/// if TR-TR only lines
				retroString  = retStringTwo.replace(charD, " goes Direct");
			}
		}
	return retroString;
	}
	
	// new method // --------------------------------------------------------------	 	
	static String chkAddDTEND (String theLine) {
		String newDTEND = theLine;
		if ( theLine.contains("DTSTAR") )   {  // double check
			if  ( !theLine.contains("VALUE")) { //moon for the  day			
			String newback = theLine.substring(8,23) + "Z";
			newDTEND = newfront + newback;  					
			out.println(" !! inside chkAddDTEND -----   @@@@@  the line is  " + theLine);
			out.println("DTEND: new line is " + newDTEND);
		}
	}
	return newDTEND;
	}	

	// new method // --------------------------------------------------------------	 	
	public static void delFiles(String f2in) {
		File f1 = new File(f2in);
		if ( f1.exists() ) {
			f1.delete();  // delete the inFileName we made last time
		}
	}

	// new method // --------------------------------------------------------------	 	
	protected static void mySleep(long timewait) {
		try {
			Thread.sleep(timewait * 1000);	//sleep is in milliseconds
		} catch (Exception e) {
			System.out.println(e);
		} 
	  } // mySleep
	
	// new method // --------------------------------------------------------------	 	
	static String chkForWeirdChar(String checkLine) {
		if (checkLine.contains( "\uFFFD"))  {
			System.out.println("!!!---            ---FOUND WEIRD CHAR -----!!!!  !!! \n" + checkLine);	
			String newStringy  =  checkLine.replace( "\uFFFD", " ");  
			System.out.println("The fixed line: " + newStringy);
			return newStringy;
		}
		else { return checkLine; }
	}
	
	//----new Method ===============================================================//
		static String replaceSigns(String theInputStr) {
			String answerst =theInputStr;
			String tsign = EMPTYstr;
			String aspace = EMPTYstr;
			String theMoon = EMPTYstr;
			boolean theProblem = false;
			verboseOut("inside replaceSigns");		
			HashMap <String, String> signHashMap =  new HashMap<>(signsMap);
			String ShortSpace = theInputStr.substring(21,22);
			if (ShortSpace.equals(" ")) {
				 theProblem = true;
			}			
			if (!theProblem) {     // continue as usual
				aspace = theInputStr.substring(23,24);
				if (aspace.equals(" ")) {
					 tsign = theInputStr.substring(24,26);
					}
				else tsign = theInputStr.substring(23,25);
			}			
			if (theProblem) {     // scoot everything over one space
				aspace = theInputStr.substring(22,23);
				if (aspace.equals(" ")) {
					 tsign = theInputStr.substring(23,25);
					}
					 else tsign = theInputStr.substring(22,24);
				}
					 
			theMoon = theInputStr.substring(8,19);
			if ((theMoon.contains("New Moon")) || (theMoon.contains("Full Moon")) ) {
				answerst = theInputStr.replace(tsign, signHashMap.get(tsign));
				}
			else {
				for (String key : signHashMap.keySet()) {       // check for other possibilities
				   answerst = checkForSigns(theInputStr, key, signHashMap.get(key));
					}   
				}
			verboseOut("val of answerst is: " + answerst);
			return answerst;
		}	

		static String checkForSigns(String origLine, String theVal, String theRep) {
			verboseOut("inside checkForSigns checking val rep: "+theVal + theRep);		
			if (origLine.contains(theVal))  {
				String theFixedLine = origLine.replace( theVal, theRep);  
				out.println("---------FOUND sign CHAR ------------------The fixed line: " + theFixedLine);
				return theFixedLine;
			}
			else return origLine;	
		}
    
		static void sectionTaskTwo(String tFILEin, String tFILEtwo,  String finFILE) {   // this part was done by perl script
			int totInFileLines=0;
			int totInfilesMinusNine=0;
			int locLineCount=4;  // start at 5th line
			String LINE_FEED = System.getProperty("line.separator");
			File tmpFILtwo = new File(tFILEtwo);
			File theREADING_FROM_TMP_FILE = new File(tFILEin);
			File finalFILE = new File(finFILE);
			System.out.println("tFILEin: " + tFILEin + "finFILE: " + finFILE + "tFILEtwo: " + tFILEtwo);
			ArrayList<String> lastFILE_ARRAY = new ArrayList<>();
			try {
				List<String> tempFILE_ARRAY =  FileUtils.readLines(theREADING_FROM_TMP_FILE);
				totInFileLines = tempFILE_ARRAY.size();
				System.out.println("!!! INSIDE sectiontask. total lines: " + totInFileLines +" " 
						+ tmpFILtwo.getName() + "and lincount is : " + locLineCount);
				// get ics header lines in 1st-first four header lines of ics inFileName

				for (int i = 0; i < 4; i++)	{
					lastFILE_ARRAY.add(tempFILE_ARRAY.get(i));
				}
				totInfilesMinusNine = totInFileLines - 9;  //  
				System.out.println("!!! totInfilesMinusNine: " + totInfilesMinusNine );

				while ( locLineCount < totInfilesMinusNine )  {                 // while there are still lines left in array // starting on 5th line, load
					ArrayList<String> tinySectionList = new ArrayList<>();

					// first load sections of 10x lines each into smaller arrarys  then check each section for voids etc  then correct
					for (int tc=0; tc < 17; tc++) {         //tiny while
						String theString = tempFILE_ARRAY.get(locLineCount);  //get one string
						boolean checkforend = theString.startsWith("END:VEVENT", 0);
						if (checkforend) {
							tinySectionList.add(theString);
							locLineCount++;
							break;
						}
						if ( !checkforend) {
							if (theString.contains("Stationary") &&  (theString.contains("DESCRIPTION") )	)
									theString = theString + LINE_FEED;
							tinySectionList.add(theString);
							locLineCount++;
						}
					}  //for

					boolean checkToKeep = true;
					if (tinySectionList.size() > 6) {
						checkToKeep = checkSUMMARYforToss(tinySectionList);	 // true is keep and write 
					}
					if (checkToKeep) {   // IF 	checkfortoss comes back TRUE, then write this section
						lastFILE_ARRAY.addAll(tinySectionList);
					}
				} //  // while locLineCount
				lastFILE_ARRAY.add("END:VCALENDAR"+LINE_FEED);
	
				List<Integer> cntLONG = new ArrayList<>();
				int newARRAYSIZE = lastFILE_ARRAY.size();
				int curLINEct = 0;
			
				while ( curLINEct < newARRAYSIZE) {    // while we're still in the file
					boolean yesDESC = false;
					String longstr = EMPTYstr;
					String tline = lastFILE_ARRAY.get(curLINEct);
					if (tline.contains("DESCRIPTION")) {
						yesDESC = true;
						cntLONG.clear();
						cntLONG.add(curLINEct);
						longstr = concatDESC (tline, lastFILE_ARRAY, curLINEct, cntLONG);  
					}	// if DESCRIPTION

					if (yesDESC) {
						addmyLines (cntLONG, lastFILE_ARRAY, longstr);
					}
					cntLONG.clear();
					newARRAYSIZE=lastFILE_ARRAY.size();
					curLINEct++;  //move the line counter up to the next group
				}  // while

				FileUtils.writeLines(finalFILE, lastFILE_ARRAY, true);
				mySleep(1);
				FileUtils.waitFor(finalFILE, 1);
			}  // try  
			catch (IOException e) {  	e.printStackTrace();	 }	// catch
		}  // end of method


	// new method: ----------------------------------------------------------------	
		static String concatDESC (String ttline, List<String> fileARY, int cLineCT, List<Integer> cLONG) {
			String concatline1 = EMPTYstr;
			String concatline2 = EMPTYstr;
			String concatline3 = EMPTYstr;
			String concatline4 = EMPTYstr;
			String longstraa = EMPTYstr;
			cLONG.add(cLineCT+1);
			concatline1=fileARY.get(cLineCT+1);

			if (fileARY.get(cLineCT+2).startsWith(" ")) {
				concatline2=fileARY.get(cLineCT+2);
				cLONG.add(cLineCT+2);

				if (fileARY.get(cLineCT+3).startsWith(" ")) {
					concatline3=fileARY.get(cLineCT+3);
					cLONG.add(cLineCT+3);

					if (fileARY.get(cLineCT+4).startsWith(" ")) {
						concatline4=fileARY.get(cLineCT+4);
						cLONG.add(cLineCT+4);
					}  
				}  
			}  
			String longstaar=longstraa.concat(ttline + concatline1 + concatline2 + concatline3 + concatline4);
			out.println("longstring is : " +longstaar);
			return longstaar;
		}

	// new method: ----------------------------------------------------------------	
		static List<String> addmyLines (List<Integer> cntLONG, List<String> farray, String longstrg) {
			int numberRemoved = cntLONG.size();  // should be around 3					
			int ttInt=cntLONG.get(0);
			for (int i=0; i < numberRemoved; i++) {
				ttInt=cntLONG.get(0);
				farray.remove(ttInt);  // remove little strings
			}
			int wheretoaddline = cntLONG.get(0);
			farray.add(wheretoaddline, longstrg);  // add new long string back
			return farray;
		} 	

	// new method: ----------------------------------------------------------------
		static boolean checkSUMMARYforToss(List<String> tinyList) {
			String sl = tinyList.get(6);  // checking the 6th line : SUMMARY
			out.println("   starting over in checkForTossouts. The string is:  " + sl );
			if (sl.contains("SUMMARY")) {
				 if ((sl.contains(":Full")) || ( sl.contains(":New Moon")) || ( sl.contains("Eclipse"))) {   // we are removing the quarters
					return true;   //keep
				 	}
				else if ((sl.contains("Moon enters")) ||  (sl.contains("Quarter")) ) {
					out.println("==========    ===== !!!!! reg method Moon enters or Quarter! ========== tossing: "+ sl);		
					return false;  // toss
				}
			}
			return true;
		}  // method end
}  // class
 